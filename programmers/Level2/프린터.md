## 프린터

<hr/>

### :heavy_check_mark: 내가 푼 답안

```javascript
function solution(priorities, location) {
  let answer = 0;
  const len = priorities.length;

  while (true) {
    const word = priorities[0];
    const important = priorities.findIndex((e) => e > word);

    if (important != -1) {
      if (location == 0) {
        location = priorities.length;
      }
      priorities.push(word);
    } else {
      answer++;
      if (location == 0) {
        break;
      }
    }

    priorities.shift();
    location--;
  }
  return answer;
}
```

맨 앞 작업을 word라고 하고, `findIndex`함수를 통해 word보다 큰 값이 있는 지 체크한다.  
만약 `if (important != -1) {` 큰 값이 있으면 맨 앞 작업을 맨 뒤로 보내준다.  
작업에서 큰 값이 없을 경우는 answer을 늘려준다.  
그리고 작업에서 맨앞 작업을 `shift()`로 빼주고 location을 줄여준다.(내가 알고싶은 작업 위치를 --)

여기서  
`if (location == 0) {`을 하는 이유는 만약 알고 싶은 작업이 맨앞에 도달했을 경우를 체크해주기 위해서이다.

1. 큰 값이 있을때는 프린트하지 못하고 location을 작업들 길이만큼 바꿔준다.
2. 큰 값이 없을때는 break해준다.

<hr/>

### :heavy_check_mark: 참고하면 좋은 다른 답안

Thanks for https://programmers.co.kr/learn/courses/30/lessons/42587/solution_groups?language=javascript

```javascript
function solution(priorities, location) {
  var list = priorities.map((t, i) => ({
    my: i === location,
    val: t
  }));
  var count = 0;
  while (true) {
    var cur = list.splice(0, 1)[0];
    if (list.some((t) => t.val > cur.val)) {
      list.push(cur);
    } else {
      count++;
      if (cur.my) return count;
    }
  }
}
```

새로운 object를 만들어서 내가 알고싶은 작업만 my를 넣어준다.  
그리고 my랑 같은 값이 프린트 되면 return 해준다.  
이 방법도 생각해봤는데 어떻게 object를 만들지를 몰라서 포기했는데.. 좋은 방법이다.

### arr.some(callback[, thisArg]) : 배열 안의 어떤 요소라도 주어진 판별 함수를 통과하는지 테스트

- callback :각 요소를 시험할 함수. 다음 세 가지 인수를 받습니다.
  1. currentValue : 처리할 현재 요소.
  2. index Optional : 처리할 현재 요소의 인덱스.
  3. array Optional :some을 호출한 배열.
- thisArg Optional : callback을 실행할 때 this로 사용하는 값.

- 반환값 : boolean

<br/>
